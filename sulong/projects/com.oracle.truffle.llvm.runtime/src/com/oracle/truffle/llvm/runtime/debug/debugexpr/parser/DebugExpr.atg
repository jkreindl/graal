import com.oracle.truffle.api.Scope;
import com.oracle.truffle.api.TruffleLanguage.InlineParsingRequest;
import com.oracle.truffle.llvm.runtime.nodes.api.LLVMExpressionNode;
import com.oracle.truffle.llvm.runtime.ArithmeticOperation;
import com.oracle.truffle.llvm.runtime.CompareOperator;
import com.oracle.truffle.llvm.runtime.LLVMContext;
import com.oracle.truffle.llvm.runtime.NodeFactory;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.*;
import com.oracle.truffle.llvm.runtime.types.Type;
// Set the name of your grammar here (and at the end of this grammar):
COMPILER DebugExpr

// Add auxiliary methods and declaration here.
boolean IsCast() {
	return false;
}

private Iterable<Scope> scopes;
private InlineParsingRequest inlineParsingRequest;
private LLVMExpressionNode astRoot=null;
private LLVMContext context=null;

void SetScopes(Iterable<Scope> scopes) {
	this.scopes = scopes;
}

void SetContext(LLVMContext context) {
	this.context = context;
}

void SetParsingRequest(InlineParsingRequest inlineParsingRequest) {
	this.inlineParsingRequest=inlineParsingRequest;
}

public int GetErrors() {
	return errors.count;
}

public LLVMExpressionNode GetASTRoot() {return astRoot; }
public NodeFactory NF() {return context.getNodeFactory(); }
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
   letter = 'A'..'Z' + 'a'..'z'.
   digit = "0123456789".
   cr = '\r'.
   lf = '\n'.
   singlecomma = '\''.
   quote = '"'.


TOKENS
// Add token declarations here.
// Example:
   ident = letter {letter | digit}.
   number = digit {digit}.
   floatnumber = digit letter.
   charConst = singlecomma (letter|digit) singlecomma.
   stringType = quote {letter|digit} quote.

PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .
DebugExpr		(. LLVMExpressionNode n=null; .)
=
Expr<out n>		(. astRoot =n; .)
.

PrimExpr<out LLVMExpressionNode n>	(. n=null; .)
=
ident 			(. n = new DebugExprVarNode(t.val, scopes); if(n==DebugExprVarNode.noObj) SemErr("variable not found: "+t.val);	.)
|
number			(. n = NF().createSimpleConstantNoArray(Integer.parseInt(t.val), Type.getIntegerType(32)); .)
|
floatnumber		
|
charConst			
|
stringType		
|
"(" Expr<out n> ")"
.

Designator<out LLVMExpressionNode n> (. LLVMExpressionNode idx=null; List<LLVMExpressionNode> l; .)
=
PrimExpr<out n> 
{
	 "[" Expr<out idx> "]"
	|
	 ActPars<out l>
	|
	 "." ident
	|
	 "->" ident
}
.

ActPars<out List l>					(. LLVMExpressionNode n1=null, n2=null; l = new LinkedList<LLVMExpressionNode>(); .)
=
"(" 
[
	 Expr<out n1> 				(. l.add(n1); .)
	{
		 "," Expr<out n2>		(. l.add(n2); .)
	}
	
]
")"
.

UnaryExpr<out LLVMExpressionNode n>	(. n=null; .)
=
Designator<out n>
|
UnaryOp CastExpr<out n>
|
"sizeof" "(" Type ")"
.

UnaryOp
=
"&"
|
"*"
|
"+"
|
"-"
|
"~"
|
"!"
.
CastExpr<out LLVMExpressionNode n> (. Object typeO=null; .)
=
[
	IF (IsCast()) "(" Type ")"
]
UnaryExpr<out n>
.

MultExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
CastExpr<out n> 
{
		 "*" CastExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.MUL, null, n, n1); .)		
		|
		 "/" CastExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.DIV, null, n, n1); .)
		|
		 "%" CastExpr<out n1> 	(. n = NF().createArithmeticOp(ArithmeticOperation.REM, null, n, n1); .)
}
.
AddExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
MultExpr<out n> 			
{
		 "+" MultExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.ADD, null, n, n1); .)		
		|
		 "-" MultExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.SUB, null, n, n1); .)	 
}
.
ShiftExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
AddExpr<out n> 
{
		 "<<"	 AddExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.SHL, null, n, n1); .)
		|
		 ">>"	 AddExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.ASHR, null, n, n1); .)
}
.
RelExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
ShiftExpr<out n> 
{
		 "<"	ShiftExpr<out n1>	(. n = NF().createComparison(CompareOperator.INT_SIGNED_LESS_THAN, null, n, n1); .)
		|
		 ">"	ShiftExpr<out n1>	(. n = NF().createComparison(CompareOperator.INT_SIGNED_GREATER_THAN, null, n, n1); .)
		|
		 "<="	ShiftExpr<out n1>	(. n = NF().createComparison(CompareOperator.INT_SIGNED_LESS_OR_EQUAL, null, n, n1); .)
		|
		 ">="	ShiftExpr<out n1>	(. n = NF().createComparison(CompareOperator.INT_SIGNED_GREATER_OR_EQUAL, null, n, n1); .)
}
.
EqExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
RelExpr<out n> 
{
		 "==" RelExpr<out n1>		(. n = NF().createComparison(CompareOperator.INT_EQUAL, null, n, n1); .)
		|
		 "!=" RelExpr<out n1>		(. n = NF().createComparison(CompareOperator.INT_NOT_EQUAL, null, n, n1); .) 
}
.
AndExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
EqExpr<out n> 
{
	 "&" EqExpr<out n1>		(. n = NF().createArithmeticOp(ArithmeticOperation.AND, null, n, n1); .)
}
.

XorExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
AndExpr<out n> 
{
	 "^" AndExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.XOR, null, n, n1); .)
}
.

OrExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
XorExpr<out n> 
{
	 "|" XorExpr<out n1>	(. n = NF().createArithmeticOp(ArithmeticOperation.OR, null, n, n1); .)
}
.

LogAndExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
OrExpr<out n> 
{
	 "&&" OrExpr<out n1>	(. n= new DebugExprSCENode(n, n1, DebugExprSCENode.SCEKind.AND); .)	
}
.

LogOrExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
LogAndExpr<out n> 
{
	 "||" LogAndExpr<out n1>	(. n= new DebugExprSCENode(n, n1, DebugExprSCENode.SCEKind.OR); .)	
}
.

Expr<out LLVMExpressionNode n>	(. LLVMExpressionNode nThen=null, nElse=null; .)
=
LogOrExpr<out n>
[
	 "?" Expr<out nThen> ":" Expr<out nElse>	(. n = new DebugExprTernaryNode(n, nThen, nElse); if(n==DebugExprVarNode.noObj) SemErr("Condition unreadable");.)
]
.

Type
=
BaseType 
(
	 
	{
		 "*"
	}
	
	|
	 "&"
)
{
	 "[" 
	[
		 number
	]
	 "]"
}
.
BaseType
=
"void"
|
ident
|
(
	 "signed"
	|
	 "unsigned"
)
[
	 "char"
	|
	 "short"
	|
	 "int"
	|
	 "long"
]
|
"char"
|
"short"
|
"int"
|
"long" 
[
	 "double"
]
|
"float"
|
"double"
.


// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END DebugExpr.

