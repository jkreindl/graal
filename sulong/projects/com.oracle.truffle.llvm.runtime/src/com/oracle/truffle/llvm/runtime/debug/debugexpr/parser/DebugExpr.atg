import java.util.LinkedList;
import com.oracle.truffle.api.Scope;
import com.oracle.truffle.api.TruffleLanguage.ContextReference;
import com.oracle.truffle.llvm.runtime.nodes.api.LLVMExpressionNode;
import com.oracle.truffle.llvm.runtime.ArithmeticOperation;
import com.oracle.truffle.llvm.runtime.LLVMContext;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.*;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.DebugExprCompareNode.Op;
import com.oracle.truffle.llvm.runtime.types.Type;
import com.oracle.truffle.llvm.runtime.types.PrimitiveType;
import com.oracle.truffle.llvm.runtime.types.VoidType;
import org.graalvm.collections.Pair;
// Set the name of your grammar here (and at the end of this grammar):
COMPILER DebugExpr

// Add auxiliary methods and declaration here.
boolean IsCast() {
	Token peek = scanner.Peek();
	if(la.kind==_lpar) {
	    while(peek.kind==_asterisc) peek=scanner.Peek();
	    int k = peek.kind;
	    if(k==_signed||k==_unsigned||k==_int||k==_long||k==_char||k==_short||k==_float||k==_double) return true;
	}
	return false;
}

private Iterable<Scope> scopes;
private LLVMExpressionNode astRoot=null;
private ContextReference<LLVMContext> contextReference=null;
private DebugExprNodeFactory NF;
public final static DebugExprErrorNode noObjNode = DebugExprErrorNode.create("<cannot find expression>");
public final static DebugExprErrorNode errorObjNode = DebugExprErrorNode.create("<cannot evaluate expression>");

void SetScopes(Iterable<Scope> scopes) {
	this.scopes = scopes;
}

void SetContextReference(ContextReference<LLVMContext> contextReference) {
	this.contextReference = contextReference;
	NF = DebugExprNodeFactory.getInstance(contextReference);
}

public int GetErrors() {
	return errors.count;
}

public LLVMExpressionNode GetASTRoot() {return astRoot; }
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
   letter = 'A'..'Z' + 'a'..'z'.
   digit = "0123456789".
   cr = '\r'.
   lf = '\n'.
   singlecomma = '\''.
   quote = '"'.


TOKENS
// Add token declarations here.
// Example:
   ident = letter {letter | digit}.
   number = digit {digit}.
   floatnumber = digit {digit} "." digit {digit} [ ("e"|"E") ["+"|"-"] digit {digit}].
   charConst = singlecomma (letter|digit) singlecomma.
   stringType = quote {letter|digit} quote.
   lpar = '('.
   asterisc = '*'.
   signed = "signed".
   unsigned = "unsigned".
   int = "int".
   long = "long".
   short = "short".
   float = "float".
   double = "double".
   char = "char".

PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .
DebugExpr		(. LLVMExpressionNode n=null; .)
=
Expr<out n> 	(. if(errors.count==0) astRoot =n; .)
.

PrimExpr<out LLVMExpressionNode n>		(. n=errorObjNode; .)
=
ident 								(. n = NF.createVarNode(t.val, scopes);.)
|
number 								(. n = NF.createIntegerConstant(Integer.parseInt(t.val)); .)
|
floatnumber							(. n = NF.createFloatConstant(Float.parseFloat(t.val)); .)					
|
charConst
|
stringType
|
"(" Expr<out n> ")"
.

Designator<out LLVMExpressionNode n>	(. LLVMExpressionNode idx=null; List<LLVMExpressionNode> l; .)
=
PrimExpr<out n> 
{
	 "[" Expr<out idx> "]"
	|
	 ActPars<out l>
	|
	 "." ident
	|
	 "->" ident
}
.

ActPars<out List l>		(. LLVMExpressionNode n1=null, n2=null; l = new LinkedList<LLVMExpressionNode>(); .)
=
"(" 
[
	 Expr<out n1> 		(. l.add(n1); .)
	 
	{
		 "," Expr<out n2> (. l.add(n2); .)
		
	}
	
]
")"
.

UnaryExpr<out LLVMExpressionNode n>		(. n=null; int kind=-1; Pair typeP=null;.)
=
Designator<out n>
|
UnaryOp<out kind> CastExpr<out n> 		(. switch(kind) {
												case 0:/*n = address(n)*/ break;
												case 1: /*deref(n)*/ break;
												case 2: default: break;
												case 3: n = NF.createArithmeticOp(ArithmeticOperation.SUB, null,
												NF.createIntegerConstant(0)
												, n); break;
												case 4: /*flip bits*/ break;
												case 5: /*negate boolean/int*/ break;
											} .)
|
"sizeof" "(" DType<out typeP> ")"	(. n=NF.createSizeofNode((Type)typeP.getLeft()); .)
.

UnaryOp<out int kind>		(. kind=-1; .)
=
"&" 						(. kind=0; .)
|
"*" 						(. kind=1; .)
|
"+" 						(. kind=2; .)
|
"-" 						(. kind=3; .)
|
"~" 						(. kind=4; .)
|
"!" 						(. kind=5; .)
.
CastExpr<out LLVMExpressionNode n>		(. Pair typeP=null; .)
=
[
	IF (IsCast()) "(" DType<out typeP> ")" 
]
UnaryExpr<out n>			(. if(typeP!=null) {
									if((Boolean)typeP.getRight()) {
										n = NF.createSignedCast(n, (Type) typeP.getLeft());
									} else {
										n = NF.createUnsignedCast(n, (Type) typeP.getLeft());
									}
										} .)
.

MultExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
CastExpr<out n> 
{
	 "*" CastExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.MUL, null, n, n1); .)
	
	|
	 "/" CastExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.DIV, null, n, n1); .)
	
	|
	 "%" CastExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.REM, null, n, n1); .)
	
}
.
AddExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
MultExpr<out n> 
{
	 "+" MultExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/ n = NF.createArithmeticOp(ArithmeticOperation.ADD, null, n, n1); .)
	
	|
	 "-" MultExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/ n = NF.createArithmeticOp(ArithmeticOperation.SUB, null, n, n1); .)
	
}
.
ShiftExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
AddExpr<out n> 
{
	 "<<" AddExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.SHL, null, n, n1); .)
	
	|
	 ">>" AddExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.ASHR, null, n, n1); .)
	
}
.
RelExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
ShiftExpr<out n> 
{
	 "<" ShiftExpr<out n1> 				(./*null is passed as type, since a type check is done by the compare node anyway*/
	 										n = NF.createCompareNode(n, Op.LT, n1); .)
	
	|
	 ">" ShiftExpr<out n1> 				(./*null is passed as type, since a type check is done by the compare node anyway*/
											n = NF.createCompareNode(n, Op.GT, n1); .)
	
	|
	 "<=" ShiftExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
											n = NF.createCompareNode(n, Op.LE, n1); .)
	
	|
	 ">=" ShiftExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
											n = NF.createCompareNode(n, Op.GE, n1); .)
	
}
.
EqExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
RelExpr<out n> 
{
	 "==" RelExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
										n = NF.createCompareNode(n, Op.EQ, n1); .)
	
	|
	 "!=" RelExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
										n = NF.createCompareNode(n, Op.NE, n1); .)
	
}
.
AndExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
EqExpr<out n> 
{
	 "&" EqExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.AND, null, n, n1); .)
	
}
.

XorExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
AndExpr<out n> 
{
	 "^" AndExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF.createArithmeticOp(ArithmeticOperation.XOR, null, n, n1); .)
	
}
.

OrExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
XorExpr<out n> 
{
	 "|" XorExpr<out n1> 			(. /*null is passed as type, since a type check is done by the arithmetic node anyway*/
										n = NF.createArithmeticOp(ArithmeticOperation.OR, null, n, n1); .)
	
}
.

LogAndExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
OrExpr<out n> 
{
	 "&&" OrExpr<out n1> 				(. n= NF.createLogicalAndNode(n, n1); .)
	
}
.

LogOrExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
LogAndExpr<out n> 
{
	 "||" LogAndExpr<out n1> 			(. n= NF.createLogicalOrNode(n, n1); .)
	
}
.

Expr<out LLVMExpressionNode n>					(. LLVMExpressionNode nThen=null, nElse=null; .)
=
LogOrExpr<out n> 
[
	 "?" Expr<out nThen> ":" Expr<out nElse> (. n = NF.createTernaryNode(n, nThen, nElse);.)
	
]
.

DType<out Pair ty>	
=
BaseType<out ty> 
(
	 
	{
		 "*"	(. SemErr("Pointer types are not available yet"); .)
	}
		
	|
	 "&"	(. SemErr("Reference types are not available yet"); .)
)
{
	 "[" 	(. SemErr("Array types are not available yet"); .)
	[
		 number
	]
	 "]"
}
.
BaseType<out Pair ty> 	(. ty=null; boolean signed=true;.)
=
"void"			(. ty = Pair.create(VoidType.INSTANCE, false); .)
|
ident
|
(
	 "signed"	(. signed = true; .)
	|
	 "unsigned"	(. signed = false; .)
)
[
	 "char"		(. ty = Pair.create(PrimitiveType.I8, signed); .)
	|
	 "short"	(. ty = Pair.create(PrimitiveType.I16, signed); .)
	|
	 "int"		(. ty = Pair.create(PrimitiveType.I32, signed); .)
	|
	 "long"		(. ty = Pair.create(PrimitiveType.I64, signed); .)
]
|
"char"			(. ty = Pair.create(PrimitiveType.I8, false);.)
|
"short"			(. ty = Pair.create(PrimitiveType.I16, true);.)
|
"int"			(. ty = Pair.create(PrimitiveType.I32, true);.)
|
"long" 			(. ty = Pair.create(PrimitiveType.I64, true);.)
[
	 "double"	(. ty = Pair.create(PrimitiveType.F128, true);.)
]
|
"float"			(. ty = Pair.create(PrimitiveType.FLOAT, true);.)
|
"double"		(. ty = Pair.create(PrimitiveType.DOUBLE, true);.)
.


// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END DebugExpr.

