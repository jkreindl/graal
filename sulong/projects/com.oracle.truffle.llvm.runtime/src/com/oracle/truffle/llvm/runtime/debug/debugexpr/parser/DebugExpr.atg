import com.oracle.truffle.api.Scope;
import com.oracle.truffle.llvm.runtime.nodes.api.LLVMExpressionNode;
import com.oracle.truffle.llvm.runtime.ArithmeticOperation;
import com.oracle.truffle.llvm.runtime.LLVMContext;
import com.oracle.truffle.llvm.runtime.NodeFactory;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.*;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.DebugExprCompareNode.Op;
import com.oracle.truffle.llvm.runtime.types.Type;
import com.oracle.truffle.llvm.runtime.types.PrimitiveType;
// Set the name of your grammar here (and at the end of this grammar):
COMPILER DebugExpr

// Add auxiliary methods and declaration here.
boolean IsCast() {
	return false;
}

private Iterable<Scope> scopes;
private LLVMExpressionNode astRoot=null;
private LLVMContext context=null;
public final static DebugExprErrorNode noObjNode = new DebugExprErrorNode("<cannot find expression>");
public final static DebugExprErrorNode errorObjNode = new DebugExprErrorNode("<cannot evaluate expression>");

void SetScopes(Iterable<Scope> scopes) {
	this.scopes = scopes;
}

void SetContext(LLVMContext context) {
	this.context = context;
}

public int GetErrors() {
	return errors.count;
}

public LLVMExpressionNode GetASTRoot() {return astRoot; }
public NodeFactory NF() {return context.getNodeFactory(); }
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
   letter = 'A'..'Z' + 'a'..'z'.
   digit = "0123456789".
   cr = '\r'.
   lf = '\n'.
   singlecomma = '\''.
   quote = '"'.


TOKENS
// Add token declarations here.
// Example:
   ident = letter {letter | digit}.
   number = digit {digit}.
   floatnumber = digit {digit} "." digit {digit} [ ("e"|"E") ["+"|"-"] digit {digit}].
   charConst = singlecomma (letter|digit) singlecomma.
   stringType = quote {letter|digit} quote.

PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .
DebugExpr		(. LLVMExpressionNode n=null; .)
=
Expr<out n> 	(. if(errors.count==0) astRoot =new DebugExprRootNode(n); .)
.

PrimExpr<out LLVMExpressionNode n>		(. n=errorObjNode; .)
=
ident 								(. n = new DebugExprVarNode(t.val, scopes);.)
|
number 								(. n = NF().createSimpleConstantNoArray(Integer.parseInt(t.val), PrimitiveType.I32); .)
|
floatnumber							(. n = NF().createSimpleConstantNoArray(Float.parseFloat(t.val), PrimitiveType.FLOAT); .)					
|
charConst
|
stringType
|
"(" Expr<out n> ")"
.

Designator<out LLVMExpressionNode n>	(. LLVMExpressionNode idx=null; List<LLVMExpressionNode> l; .)
=
PrimExpr<out n> 
{
	 "[" Expr<out idx> "]"
	|
	 ActPars<out l>
	|
	 "." ident
	|
	 "->" ident
}
.

ActPars<out List l>		(. LLVMExpressionNode n1=null, n2=null; l = new LinkedList<LLVMExpressionNode>(); .)
=
"(" 
[
	 Expr<out n1> 		(. l.add(n1); .)
	 
	{
		 "," Expr<out n2> (. l.add(n2); .)
		
	}
	
]
")"
.

UnaryExpr<out LLVMExpressionNode n>		(. n=null; int kind=-1; Type typeO=null;.)
=
Designator<out n>
|
UnaryOp<out kind> CastExpr<out n> 		(. switch(kind) {
												case 0:/*n = address(n)*/ break;
												case 1: /*deref(n)*/ break;
												case 2: default: break;
												case 3: n = NF().createArithmeticOp(ArithmeticOperation.SUB, null,
												NF().createSimpleConstantNoArray(0, Type.getIntegerType(32))
												, n); break;
												case 4: /*flip bits*/ break;
												case 5: /*negate boolean/int*/ break;
											} .)
|
"sizeof" "(" DType<out typeO> ")"	(. n=new DebugExprSizeofNode(typeO); .)
.

UnaryOp<out int kind>		(. kind=-1; .)
=
"&" 						(. kind=0; .)
|
"*" 						(. kind=1; .)
|
"+" 						(. kind=2; .)
|
"-" 						(. kind=3; .)
|
"~" 						(. kind=4; .)
|
"!" 						(. kind=5; .)
.
CastExpr<out LLVMExpressionNode n>		(. Type typeO=null; .)
=
[
	IF (IsCast()) "(" DType<out typeO> ")"
]
UnaryExpr<out n>
.

MultExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
CastExpr<out n> 
{
	 "*" CastExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.MUL, null, n, n1); .)
	
	|
	 "/" CastExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.DIV, null, n, n1); .)
	
	|
	 "%" CastExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.REM, null, n, n1); .)
	
}
.
AddExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
MultExpr<out n> 
{
	 "+" MultExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/ n = NF().createArithmeticOp(ArithmeticOperation.ADD, null, n, n1); .)
	
	|
	 "-" MultExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/ n = NF().createArithmeticOp(ArithmeticOperation.SUB, null, n, n1); .)
	
}
.
ShiftExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
AddExpr<out n> 
{
	 "<<" AddExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.SHL, null, n, n1); .)
	
	|
	 ">>" AddExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.ASHR, null, n, n1); .)
	
}
.
RelExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
ShiftExpr<out n> 
{
	 "<" ShiftExpr<out n1> 				(./*null is passed as type, since a type check is done by the compare node anyway*/
	 										n = new DebugExprCompareNode(NF(), n, Op.LT, n1); .)
	
	|
	 ">" ShiftExpr<out n1> 				(./*null is passed as type, since a type check is done by the compare node anyway*/
											n = new DebugExprCompareNode(NF(), n, Op.GT, n1); .)
	
	|
	 "<=" ShiftExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
											n = new DebugExprCompareNode(NF(), n, Op.LE, n1); .)
	
	|
	 ">=" ShiftExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
											n = new DebugExprCompareNode(NF(), n, Op.GE, n1); .)
	
}
.
EqExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
RelExpr<out n> 
{
	 "==" RelExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
										n = new DebugExprCompareNode(NF(), n, Op.EQ, n1); .)
	
	|
	 "!=" RelExpr<out n1> 			(./*null is passed as type, since a type check is done by the compare node anyway*/
										n = new DebugExprCompareNode(NF(), n, Op.NE, n1); .)
	
}
.
AndExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
EqExpr<out n> 
{
	 "&" EqExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.AND, null, n, n1); .)
	
}
.

XorExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
AndExpr<out n> 
{
	 "^" AndExpr<out n1> 				(./*null is passed as type, since a type check is done by the arithmetic node anyway*/
											n = NF().createArithmeticOp(ArithmeticOperation.XOR, null, n, n1); .)
	
}
.

OrExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
XorExpr<out n> 
{
	 "|" XorExpr<out n1> 			(. /*null is passed as type, since a type check is done by the arithmetic node anyway*/
										n = NF().createArithmeticOp(ArithmeticOperation.OR, null, n, n1); .)
	
}
.

LogAndExpr<out LLVMExpressionNode n>	(. LLVMExpressionNode n1=null; .)
=
OrExpr<out n> 
{
	 "&&" OrExpr<out n1> 				(. n= new DebugExprSCENode(n, n1, DebugExprSCENode.SCEKind.AND); .)
	
}
.

LogOrExpr<out LLVMExpressionNode n>		(. LLVMExpressionNode n1=null; .)
=
LogAndExpr<out n> 
{
	 "||" LogAndExpr<out n1> 			(. n= new DebugExprSCENode(n, n1, DebugExprSCENode.SCEKind.OR); .)
	
}
.

Expr<out LLVMExpressionNode n>					(. LLVMExpressionNode nThen=null, nElse=null; .)
=
LogOrExpr<out n> 
[
	 "?" Expr<out nThen> ":" Expr<out nElse> (. n = new DebugExprTernaryNode(n, nThen, nElse);.)
	
]
.

DType<out Type t>	
=
BaseType<out t> 
(
	 
	{
		 "*"
	}
	
	|
	 "&"
)
{
	 "[" 
	[
		 number
	]
	 "]"
}
.
BaseType<out Type t> 	(. t=null; boolean signed=true;.)
=
"void"
|
ident
|
(
	 "signed"	(. signed = true; .)
	|
	 "unsigned"	(. signed = false; .)
)
[
	 "char"		(. if(signed) {t = PrimitiveType.I8;} else {} .)
	|
	 "short"	(. if(signed) {t = PrimitiveType.I16;} else {} .)
	|
	 "int"		(. if(signed) {t = PrimitiveType.I32;} else {} .)
	|
	 "long"		(. if(signed) {t = PrimitiveType.I64;} else {} .)
]
|
"char"			(. t = PrimitiveType.I8;.)
|
"short"			(. t = PrimitiveType.I16;.)
|
"int"			(. t = PrimitiveType.I32;.)
|
"long" 			(. t = PrimitiveType.I64;.)
[
	 "double"	(. t = PrimitiveType.F128;.)
]
|
"float"			(. t = PrimitiveType.FLOAT;.)
|
"double"		(. t = PrimitiveType.DOUBLE;.)
.


// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END DebugExpr.

