import java.util.LinkedList;
import com.oracle.truffle.llvm.runtime.nodes.api.LLVMExpressionNode;
import com.oracle.truffle.llvm.runtime.ArithmeticOperation;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.*;
import com.oracle.truffle.llvm.runtime.debug.debugexpr.nodes.DebugExprNodeFactory.CompareKind;
// Set the name of your grammar here (and at the end of this grammar):
COMPILER DebugExpr

// Add auxiliary methods and declaration here.
boolean IsCast() {
	Token peek = scanner.Peek();
	if(la.kind==_lpar) {
	    while(peek.kind==_asterisc) peek=scanner.Peek();
	    int k = peek.kind;
	    if(k==_signed||k==_unsigned||k==_int||k==_long||k==_char||k==_short||k==_float||k==_double) return true;
	}
	return false;
}

private LLVMExpressionNode astRoot=null;
private DebugExprNodeFactory NF=null;

public void setNodeFactory(DebugExprNodeFactory nodeFactory) {
	if(NF==null) NF=nodeFactory;
}

public int GetErrors() {
	return errors.count;
}

public LLVMExpressionNode GetASTRoot() {return astRoot; }
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
   letter = 'A'..'Z' + 'a'..'z'.
   digit = "0123456789".
   cr = '\r'.
   lf = '\n'.
   singlecomma = '\''.
   quote = '"'.


TOKENS
// Add token declarations here.
// Example:
   ident = letter {letter | digit}.
   number = digit {digit}.
   floatnumber = digit {digit} "." digit {digit} [ ("e"|"E") ["+"|"-"] digit {digit}].
   charConst = singlecomma (letter|digit) singlecomma.
   lpar = '('.
   asterisc = '*'.
   signed = "signed".
   unsigned = "unsigned".
   int = "int".
   long = "long".
   short = "short".
   float = "float".
   double = "double".
   char = "char".

PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .
DebugExpr											(. DebugExpressionPair p=null; .)
=
Expr<out p> 										(. if(errors.count==0) astRoot =p.getNode(); .)
.

PrimExpr<out DebugExpressionPair p>					(. p=null; .)
=
ident 												(. p = NF.createVarNode(t.val);.)
|
number 												(. p = NF.createIntegerConstant(Integer.parseInt(t.val)); .)
|
floatnumber 										(. p = NF.createFloatConstant(Float.parseFloat(t.val)); .)
|
charConst											(. SemErr("characters not available yet"); .)
|
"(" Expr<out p> ")"
.

Designator<out DebugExpressionPair p>				(. DebugExpressionPair idxPair=null; List<DebugExpressionPair> l; .)
=
PrimExpr<out p> 
{
	 "[" Expr<out idxPair> "]"						(. p = NF.createArrayElement(p, idxPair); .)
	|
	 ActPars<out l>									(. p = NF.createFunctionCall(p, l); .)
	|
	 "." ident										(. p = NF.createObjectMember(p, t.val); .)
	|
	 "->" ident										(. SemErr("pointer access not available yet"); .)
}
.

ActPars<out List l>									(. DebugExpressionPair p1=null, p2=null; l = new LinkedList<DebugExpressionPair>(); .)
=
"(" 
[
	 Expr<out p1> 									(. l.add(p1); .)
	 
	{
		 "," Expr<out p2> 							(. l.add(p2); .)
		
	}
	
]
")"
.

UnaryExpr<out DebugExpressionPair p>				(. p=null; char kind='\0'; DebugExprType typeP=null;.)
=
Designator<out p>
|
UnaryOp<out kind> CastExpr<out p> 					(. p = NF.createUnaryOpNode(p, kind); .)
|
"sizeof" "(" DType<out typeP> ")" 					(. p=NF.createSizeofNode(typeP); .)
.

UnaryOp<out char kind>								(. kind='\0'; .)
=
(
	 "&"
	|
	 "*"
	|
	 "+"
	|
	 "-"
	|
	 "~"
	|
	 "!"
)
													(. kind = t.val.charAt(0); .)
.
CastExpr<out DebugExpressionPair p>					(. DebugExprType typeP=null; .)
=
[
	IF (IsCast()) "(" DType<out typeP> ")"
]
UnaryExpr<out p> 								(. if(typeP!=null) { p = NF.createCastIfNecessary(p, typeP); } .)
.

MultExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
CastExpr<out p> 
{
	 "*" CastExpr<out p1> 							(. p = NF.createArithmeticOp(ArithmeticOperation.MUL, p, p1); .)
	
	|
	 "/" CastExpr<out p1> 							(. p = NF.createDivNode(p, p1); .)
	
	|
	 "%" CastExpr<out p1> 							(. p = NF.createRemNode(p, p1); .)
	
}
.
AddExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
MultExpr<out p> 
{
	 "+" MultExpr<out p1> 							(. p = NF.createArithmeticOp(ArithmeticOperation.ADD, p, p1); .)
	
	|
	 "-" MultExpr<out p1> 							(.p = NF.createArithmeticOp(ArithmeticOperation.SUB, p, p1); .)
	
}
.
ShiftExpr<out DebugExpressionPair p>				(. DebugExpressionPair p1=null; .)
=
AddExpr<out p> 
{
	 "<<" AddExpr<out p1> 							(.p = NF.createShiftLeft(p, p1); .)
	
	|
	 ">>" AddExpr<out p1> 							(.p = NF.createShiftRight(p, p1); .)
	
}
.
RelExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
ShiftExpr<out p> 
{
	 "<" ShiftExpr<out p1> 							(. p = NF.createCompareNode(p, CompareKind.LT, p1); .)
	
	|
	 ">" ShiftExpr<out p1> 							(. p = NF.createCompareNode(p, CompareKind.GT, p1); .)
	
	|
	 "<=" ShiftExpr<out p1> 						(. p = NF.createCompareNode(p, CompareKind.LE, p1); .)
	
	|
	 ">=" ShiftExpr<out p1> 						(. p = NF.createCompareNode(p, CompareKind.GE, p1); .)
	
}
.
EqExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
RelExpr<out p> 
{
	 "==" RelExpr<out p1> 							(. p = NF.createCompareNode(p, CompareKind.EQ, p1); .)
	
	|
	 "!=" RelExpr<out p1> 							(. p = NF.createCompareNode(p, CompareKind.NE, p1); .)
	
}
.
AndExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
EqExpr<out p> 
{
	 "&" EqExpr<out p1> 							(. p = NF.createArithmeticOp(ArithmeticOperation.AND, p, p1); .)
	
}
.

XorExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
AndExpr<out p> 
{
	 "^" AndExpr<out p1> 							(.	p = NF.createArithmeticOp(ArithmeticOperation.XOR, p, p1); .)
	
}
.

OrExpr<out DebugExpressionPair p>					(. DebugExpressionPair p1=null; .)
=
XorExpr<out p> 
{
	 "|" XorExpr<out p1> 							(.  p = NF.createArithmeticOp(ArithmeticOperation.OR, p, p1); .)
	
}
.

LogAndExpr<out DebugExpressionPair p>				(. DebugExpressionPair p1=null; .)
=
OrExpr<out p> 
{
	 "&&" OrExpr<out p1> 							(. p= NF.createLogicalAndNode(p, p1); .)
	
}
.

LogOrExpr<out DebugExpressionPair p>				(. DebugExpressionPair p1=null; .)
=
LogAndExpr<out p> 
{
	 "||" LogAndExpr<out p> 						(. p= NF.createLogicalOrNode(p, p1); .)
	
}
.

Expr<out DebugExpressionPair p>						(. DebugExpressionPair pThen=null, pElse=null; .)
=
LogOrExpr<out p> 
[
	 "?" Expr<out pThen> ":" Expr<out pElse> 		(. p = NF.createTernaryNode(p, pThen, pElse);.)
	
]
.

DType<out DebugExprType ty>
=
BaseType<out ty> 
(
	 
	{
		 "*" 										(. SemErr("Pointer types are not available yet"); .)
		
	}
	
	|
	 "&" 											(. SemErr("Reference types are not available yet"); .)
	
)
{
	 "[" 											(. SemErr("Array types are not available yet"); .)
	 
	[
		 number
	]
	 "]"
}
.
BaseType<out DebugExprType ty>						(. ty=null; boolean signed=false;.)
=
"void" 												(. ty = DebugExprType.getVoidType(); .)
|
ident
|
(
	 "signed" 										(. signed = true; .)
	
	|
	 "unsigned" 									(. signed = false; .)
	
)
[
	 "char" 										(. ty = DebugExprType.getIntType(8, signed); .)
	
	|
	 "short" 										(. ty = DebugExprType.getIntType(16, signed); .)
	
	|
	 "int" 											(. ty = DebugExprType.getIntType(32, signed); .)
	
	|
	 "long" 										(. ty = DebugExprType.getIntType(64, signed); .)
	
]
|
"char" 												(. ty = DebugExprType.getIntType(8, false);.)
|
"short" 											(. ty = DebugExprType.getIntType(16, true);.)
|
"int" 												(. ty = DebugExprType.getIntType(32, true);.)
|
"long" 												(. ty = DebugExprType.getIntType(64, true);.)
[
	 "double" 										(. ty = DebugExprType.getFloatType(128); .)
	
]
|
"float" 											(. ty = DebugExprType.getFloatType(32);.)
|
"double" 											(. ty = DebugExprType.getFloatType(64);.)
.


// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END DebugExpr.

